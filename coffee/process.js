// Generated by CoffeeScript 1.9.0
(function() {
  var decode, msgpack, to_stacked_bar_data, un_rotate;

  msgpack = require('msgpack5')();

  un_rotate = function(data) {
    var arrs, keys;
    keys = Object.keys(data);
    arrs = keys.map(function(key) {
      return data[key];
    });
    arrs = d3.zip.apply(null, arrs);
    data = arrs.map(function(d) {
      var ans, i, v, _i, _len;
      ans = {};
      for (i = _i = 0, _len = d.length; _i < _len; i = ++_i) {
        v = d[i];
        ans[keys[i]] = v;
      }
      return ans;
    });
    return data;
  };

  decode = function(data) {
    return msgpack.decode(new Uint8Array(data));
  };

  to_stacked_bar_data = function(data) {
    var get_color, last_color, last_price, price_data, vol_map;
    price_data = data.map(function(d) {
      return {
        'price': d.price,
        'volume': d.volume
      };
    });
    get_color = function(last, next) {
      if (last === null) {
        return 'yellow';
      }
      if (next > last) {
        return 'green';
      } else if (next < last) {
        return 'red';
      } else {
        return null;
      }
    };
    last_price = null;
    last_color = null;
    price_data.forEach(function(d) {
      d.color = get_color(last_price, d.price) || last_color;
      last_price = d.price;
      return last_color = d.color;
    });
    vol_map = d3.nest().key(function(d) {
      return d.price;
    }).sortKeys(d3.ascending).rollup(function(leaves) {
      return leaves.map(function(d) {
        return {
          'value': d.volume,
          'color': d.color
        };
      });
    }).entries(price_data);
    return vol_map.map(function(d) {
      return {
        'name': d.key,
        'values': d.values
      };
    });
  };

  module.exports.process = process;

  module.exports.decode = decode;

  module.exports.un_rotate = un_rotate;

  module.exports.to_stacked_bar_data = to_stacked_bar_data;

}).call(this);
